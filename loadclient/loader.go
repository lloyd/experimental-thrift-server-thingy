// Autogenerated by Thrift Compiler (facebook)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
// @generated

package main

import (
	"flag"
	"fmt"
	"os"
	"sync"
	"sync/atomic"

	"../gen-go/reverse"
	thrift "github.com/facebook/fbthrift-go"
	"github.com/youtube/vitess/go/timer"
	//	"sync"
	"time"
)

func Usage() {
	fmt.Fprintln(os.Stderr, "Usage of ", os.Args[0], " [-h host:port]")
	flag.PrintDefaults()
	fmt.Fprintln(os.Stderr, "\nFunctions:")
	fmt.Fprintln(os.Stderr, "  string Do(string input)")
	fmt.Fprintln(os.Stderr, "  void DoNothing()")
	fmt.Fprintln(os.Stderr, "  string DoReturn()")
	fmt.Fprintln(os.Stderr, "  void DoArg(string input)")
	fmt.Fprintln(os.Stderr)
	os.Exit(0)
}

func main() {
	flag.Usage = Usage
	var host string
	flag.Usage = Usage
	flag.StringVar(&host, "h", "127.0.0.1:8080", "Specify host and port")
	flag.Parse()

	connectClient := func() (*reverse.ReverseClient, error) {
		var err error
		var trans thrift.Transport
		trans, err = thrift.NewSocket(thrift.SocketAddr(host), thrift.SocketTimeout(time.Second*30))
		if err != nil {
			return nil, err
		}

		if err := trans.Open(); err != nil {
			return nil, err
		}

		client := reverse.NewReverseClient(
			trans,
			thrift.NewBinaryProtocolTransport(trans),
			thrift.NewBinaryProtocolTransport(trans),
		)
		return client, nil
	}
	var wg sync.WaitGroup

	var queries uint64
	var failures uint64
	var conns int64
	t := timer.NewTimer(time.Second)
	t.Start(func() {
		qps := atomic.SwapUint64(&queries, 0)
		failps := atomic.SwapUint64(&failures, 0)
		connps := atomic.LoadInt64(&conns)
		fmt.Printf("%d connections: %d QPS (%d errors)\n", connps, qps, failps)
	})

	for i := 0; i < 1000; i++ {
		time.Sleep(time.Millisecond)
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			client, err := connectClient()
			if err != nil {
				fmt.Fprintf(os.Stderr, "failure: %s\n", err)
				atomic.AddUint64(&failures, 1)
				return
			}
			defer client.Close()

			atomic.AddInt64(&conns, 1)
			defer atomic.AddInt64(&conns, -1)

			for j := 0; j < 10000; j++ {
				//time.Sleep(time.Duration(i%20) + 100*time.Millisecond)
				//fmt.Printf("%s\n", x)
				if _, err = client.Do(fmt.Sprintf("%d: this is a string", i)); err != nil {
					atomic.AddUint64(&failures, 1)
					//					fmt.Printf("ERROR: %s\n", err)
				} else {
					atomic.AddUint64(&queries, 1)
				}
			}

		}(i)
	}
	fmt.Printf("waiting for completion\n")
	wg.Wait()
	t.Stop()
}
